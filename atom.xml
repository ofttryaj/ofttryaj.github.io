<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>big gang silk</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ofttryaj.github.io/"/>
  <updated>2016-12-21T08:32:08.000Z</updated>
  <id>https://ofttryaj.github.io/</id>
  
  <author>
    <name>ofttryaj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>beego启动流程-context.Context</title>
    <link href="https://ofttryaj.github.io/2016/12/21/beego%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-context-Context/"/>
    <id>https://ofttryaj.github.io/2016/12/21/beego启动流程-context-Context/</id>
    <published>2016-12-21T08:29:45.000Z</published>
    <updated>2016-12-21T08:32:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="beego-context-Context-context-BeegoInput-context-BeegoOutput"><a href="#beego-context-Context-context-BeegoInput-context-BeegoOutput" class="headerlink" title="beego context.Context, context.BeegoInput, context.BeegoOutput"></a>beego context.Context, context.BeegoInput, context.BeegoOutput</h3><ul>
<li>context.Context结构体:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">type Context struct &#123;</div><div class="line">	// 处理请求头，数据，cookie，body，它还包含路由参数和当前的session</div><div class="line">	Input          *BeegoInput</div><div class="line">	// 发送响应头</div><div class="line">	Output         *BeegoOutput</div><div class="line">	Request        *http.Request</div><div class="line">	ResponseWriter *Response</div><div class="line">	_xsrfToken     string</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li><p>Request，ResponseWriter字段都是由go内部根据请求创建的request，response对象传过来的，这两个对象提供了一系列跟HTTP请求相关的方法，比如判断请求方式（GET，POST），获取请求头，cookie相关的操作等等，这些方法会体现在BeegoInput，BeegoOupt方法集中；<br>Request字段是go内核中的http.Request类型，但是ResponseWriter字段，则依赖context.Response中匿名字段http.ResponseWriter的具体实现，我通过看go内核源码，可以知道，http.Resposne实现了http.ResponseWirter，并且我们也知道go内部也是创建了http.Response并且通过beego.ControllerRegister.ServeHTTP(w, req)传入的，可以看考我之前写的文章<a href="http://aj.gitgang.com/?p=106" target="_blank" rel="external">beego.ControllerRegister如何注册到go内部的</a>，对request，response的大部分操作，本质上还是go内核中的http.Request，http.Response对象提供的相关方法；</p>
</li>
<li><p>Input和Output的类型从上面的结构体可以得知，上面说了很多关于request，response相关的东西，是为了更好的理解Input和Output相关方法集，比如BeegoInput.Header(key string)方法中，就调用了input.Context.Request.Header.Get(key)等等很多这样的方法，都依赖http.Request方法集；BeegoOutput.Header(key, val string)，也调用了output.Context.ResponseWriter.Header().Set(key, val)这个方法，具体可以自己通过源码深入了解；</p>
</li>
<li><p>上面的Request,ResponseWriter是如何注入的，下面会说到。我们来了解下Context.Reset(rw http.ResponseWriter, r *http.Request), BeegoInput.Reset(ctx *Context), beegoOutput.Reset(ctx *Context)，这些方法从字面意思来看，是做重置操作的，其实也确实是在做这样的操作，在ServeHTTP(w, req)方法中我们会看到，调用context.Reset(w, req)方法</p>
<ul>
<li><p>Context.Reset()，req参数会赋给Request字段，ResponseWriter字段则要复杂点，若ResponseWriter为空，则取&amp;Response{}（这个response是beego的context.Response类型）赋值，之后调用conext.Response.reset(rw http.ResponseWriter)方法，进行重置操作，会把w赋值给Response的ResponseWriter匿名字段，后面两个字段Status = 0，Started = false。接下来调用BeegoInput.Reset()和BeegoOutput.Reset()，_xsrfToken = “”；</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">func (ctx *Context) Reset(rw http.ResponseWriter, r *http.Request) &#123;</div><div class="line">	ctx.Request = r</div><div class="line">	if ctx.ResponseWriter == nil &#123;</div><div class="line">		ctx.ResponseWriter = &amp;Response&#123;&#125;</div><div class="line">	&#125;</div><div class="line">	ctx.ResponseWriter.reset(rw)</div><div class="line">	ctx.Input.Reset(ctx)</div><div class="line">	ctx.Output.Reset(ctx)</div><div class="line">	ctx._xsrfToken = &quot;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>context.Response同时实现了http.Flusher,http.Hijacker,http.CloseNotifier三个接口。同时还重写了http.Response的Write(),WriteHeader()方法</p>
</blockquote>
</li>
<li><p>BeegoInput.Reset()会把ctx（即当前上下文对象）赋值给Context字段，剩下的就是重置字段；</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func (input *BeegoInput) Reset(ctx *Context) &#123;</div><div class="line">	input.Context = ctx</div><div class="line">	input.CruSession = nil</div><div class="line">	input.pnames = input.pnames[:0]</div><div class="line">	input.pvalues = input.pvalues[:0]</div><div class="line">	input.data = nil</div><div class="line">	input.RequestBody = []byte&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>BeegoOutput.Reset()第一步也是赋值Context字段，Status = 0；</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func (output *BeegoOutput) Reset(ctx *Context) &#123;</div><div class="line">	output.Context = ctx</div><div class="line">	output.Status = 0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么要说这么多，其实后面我们会知道beego.ControllerRegister.ServeHTTP()方法中，当请求过来的时候，go内部会把封装好了的http.Request和http.Response对象传递给这个ServeHTTP()方法中，接下来会从对象池pool中获取一个context对象，会对着这个对象进行重置操作，即context.Reset(rw, r)，我们了解Reset操作后才能更好的理解处理请求后续的操作。</p>
</blockquote>
<ul>
<li><p>我们来看看Context,BeegoInput,BeegoOuput对象提供的一些方法</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func (ctx *Context) GetCookie(key string) string &#123;</div><div class="line">	return ctx.Input.Cookie(key)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (ctx *Context) SetCookie(name string, value string, others ...interface&#123;&#125;) &#123;</div><div class="line">	ctx.Output.Cookie(name, value, others...)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>以上两个方法，大家都知道是获取cookie，设置cookie信息的功能，我们知道设置cookie信息是服务器告诉浏览器，你帮我把这些信息保存在你这，等下次浏览器请求服务器的时候，浏览器会把这些信息放在请求体中发送给服务器。我们上面也知道了BeegoInput和BeegoOutput相关含义，因此，SetCookie会调用BeegoOuput.Cookie()方法，而GetCookie()则是调用BeegoInput()方法，那么我们就来看下具体实现：

##### BeegoOuput.Cookie()

* 这个方法的签名：func (output *BeegoOutput) Cookie(name string, value string, others ...interface{})

* 先来解释下这个方法需要的参数，**name string, value string, others ...interface{}**，前两个参数一看就知道是cookie名称和值了，这个others则是**max age time, path,domain, secure and httponly**，并且是严格按照这个顺序来的；当我这样尝试着调用Cookie()方法时，

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Cookie(&quot;cookieName&quot;, &quot;CookeValue&quot;, 145, &quot;/&quot;, &quot;http://aj.gitgang.com&quot;, true, true)</div><div class="line">// 往Set-Cookie头信息写入的内容是</div><div class="line">// cookieName=CookeValue; Expires=Fri, 16 Dec 2016 08:29:19 UTC; Max-Age=145; Path=/; Domain=http://aj.gitgang.com; Secure; HttpOnly</div></pre></td></tr></table></figure>

* beego在output.go文件中封装了两个替换器**strings.NewReplacer(&quot;\n&quot;, &quot;-&quot;, &quot;\r&quot;, &quot;-&quot;)**和**strings.NewReplacer(&quot;\n&quot;, &quot; &quot;, &quot;\r&quot;, &quot; &quot;, &quot;;&quot;, &quot; &quot;)**，第一个替换器就是把\n，\r转换为-，第二个则是把\n，\r，;替换为空格
* 方法首先声明了一个var b bytes.Buffer，所有的内容都放在这个变量里；

* 先对name和value分别用上面两个替换器进行替换，接下来会按照这样的格式**&quot;%s=%s&quot;**写入变量b中；

* 接下来会判断others变量中的参数个数进行判断，上面我们说到了others这个参数，这个参数是不定长的，但是我们传入参数的含义，是按顺序定义好了的，按顺序解释如下：
    1. max age time：cookie过期时间，这里可能不恰当，但是beego确实利用这个值对cookie设置了过期时间，beego解释说为了解决cookie在IE下的问题；
    2. path：cookie路径，那些cookie在服务器上的该路径下能够被访问，如果设置&quot;/&quot;，那么这个cookie能在整个网站根目录下被访问，若设置/foo/，那么只能是/foo/及其子目录下能够访问该cookie；
    3. domain：cookie域，指定cookie发送至哪些域
    4. secure：用来表示cookie是不是仅仅只能通过安全的HTTPS连接进行传输；
    5. httponly：当设置为true，cookie只能通过http协议访问，不能被脚本语言访问，例如javascript

如果传入了一个参数并且符合条件，则往变量b中写入类似这样的**; Expires=Fri, 16 Dec 2016 08:29:19 UTC; Max-Age=145**内容，否则写入**; Max-Age=0**

如果传入了第二个参数并符合条件，则写入**; Path=/foo/**，否则**; Path=/**

如果传入第三个参数并符合条件，则写入**; Domain=http://aj.gitgang.com**，否则忽略

如果传入第四个参数并符合条件，则写入**; Secure**，否则忽略

如果传入第五个参数并符合条件，则写入**; ; HttpOnly**，否则忽略

如果参数全部传入的话，则会构造这样的一个字符串**cookieName=CookeValue; Expires=Fri, 16 Dec 2016 08:29:19 UTC; Max-Age=145; Path=/; Domain=http://aj.gitgang.com; Secure; HttpOnly**

* 最后调用output.Context.ResponseWriter.Header().Add(&quot;Set-Cookie&quot;, b.String())，放到响应头；


##### BeegoInput.Cookie()

* 这个方法的签名：func (input *BeegoInput) Cookie(key string) string 

* 方法直接调用input.Context.Request.Cookie(key)来从请求体中获取cookie的值，若出错则返回空字符串；
</code></pre><blockquote>
<p>这里只是列举了操作cookie的方法，还有像获取头部信息，请求参数，Session，响应的数据格式json，xml等等很多方法，就不一一列举了，大家可以自己去了解相关的东西</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;beego-context-Context-context-BeegoInput-context-BeegoOutput&quot;&gt;&lt;a href=&quot;#beego-context-Context-context-BeegoInput-context-BeegoOutput&quot; class=&quot;headerlink&quot; title=&quot;beego context.Context, context.BeegoInput, context.BeegoOutput&quot;&gt;&lt;/a&gt;beego context.Context, context.BeegoInput, context.BeegoOutput&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;context.Context结构体:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;type Context struct &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	// 处理请求头，数据，cookie，body，它还包含路由参数和当前的session&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	Input          *BeegoInput&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	// 发送响应头&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	Output         *BeegoOutput&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	Request        *http.Request&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	ResponseWriter *Response&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	_xsrfToken     string&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="go,beego" scheme="https://ofttryaj.github.io/tags/go-beego/"/>
    
  </entry>
  
  <entry>
    <title>beego启动流程-ControllerRegister如何注册到go内部</title>
    <link href="https://ofttryaj.github.io/2016/12/21/beego%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-ControllerRegister%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E5%88%B0go%E5%86%85%E9%83%A8/"/>
    <id>https://ofttryaj.github.io/2016/12/21/beego启动流程-ControllerRegister如何注册到go内部/</id>
    <published>2016-12-21T08:25:34.000Z</published>
    <updated>2016-12-21T08:28:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="beego-ControllerRegister"><a href="#beego-ControllerRegister" class="headerlink" title="beego.ControllerRegister"></a>beego.ControllerRegister</h1><blockquote>
<p>这里主要是讲了beego如何将自定义路由处理传递给http.Server.Hanlder字段的，并且理解Go内部是如何调用ControllerRegister.ServeHTTP()方法的。具体深入到ControllerRegister是如何处理路由的，有待进一步学习。</p>
</blockquote>
<p>在beego包中的app.go文件中定义了一个init()函数，这个方法就干了一件事情，就是创建一个App，赋值给一个全局可导出的BeeApp变量，App结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">type App struct &#123;</div><div class="line">	Handlers *ControllerRegister</div><div class="line">	Server   *http.Server</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中http.Server{}有个字段是Handler类型，这个Handler是一个接口里面只有一个函数声明，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">type Handler interface &#123;</div><div class="line">	ServeHTTP(ResponseWriter, *Request)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>在这里我们注意到了App结构体中也一个Handlers字段，这个字段的类型就是Beego框架自定义的一个类型，就是ControllerRegister，这个结构体实现了Handler接口，即实现了ServeHTTP(ResponseWriter, *Request)这个函数，这个稍后会说到为什么解释这些。<br>接下来我们看beego包下的app.go中的run()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">app.Server.Handler = app.Handlers</div><div class="line">app.Server.ReadTimeout = time.Duration(BConfig.Listen.ServerTimeOut) * time.Second</div><div class="line">app.Server.WriteTimeout = time.Duration(BConfig.Listen.ServerTimeOut) * time.Second</div><div class="line">app.Server.ErrorLog = logs.GetLogger(&quot;HTTP&quot;)</div><div class="line">...</div><div class="line">if BConfig.Listen.EnableHTTP &#123;</div><div class="line">	go func() &#123;</div><div class="line">		app.Server.Addr = addr</div><div class="line">		logs.Info(&quot;http server Running on http://%s&quot;, app.Server.Addr)</div><div class="line">		if BConfig.Listen.ListenTCP4 &#123;</div><div class="line">			...</div><div class="line">		&#125; else &#123;</div><div class="line">			if err := app.Server.ListenAndServe(); err != nil &#123;</div><div class="line">				logs.Critical(&quot;ListenAndServe: &quot;, err)</div><div class="line">				time.Sleep(100 * time.Microsecond)</div><div class="line">				endRunning &lt;- true</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这里是只是run方法的一部分代码，刚刚我们说到了ControllerRegister实现了接口Handler，这里把app.Hanlders赋值给了app.Server.Handler，这样，http.Server将会调用ControllerRegister相关方法进行路由转发，具体如何调用，在来看这个app.Server.ListenAndServe()方法，这个方法会监听tcp地址，调用服务处理连接请求，一下是代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func (srv *Server) ListenAndServe() error &#123;</div><div class="line">	addr := srv.Addr</div><div class="line">	if addr == &quot;&quot; &#123;</div><div class="line">		addr = &quot;:http&quot;</div><div class="line">	&#125;</div><div class="line">	// 创建一个监听器*net.TCPListener，监听TCP端口</div><div class="line">	ln, err := net.Listen(&quot;tcp&quot;, addr)</div><div class="line">	if err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	// 根据监听器处理请求</div><div class="line">	return srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">func (srv *Server) Serve(l net.Listener) error &#123;</div><div class="line">	defer l.Close()</div><div class="line">	...</div><div class="line"></div><div class="line">	// TODO: allow changing base context? can&apos;t imagine concrete</div><div class="line">	// use cases yet.</div><div class="line">	baseCtx := context.Background()</div><div class="line">	ctx := context.WithValue(baseCtx, ServerContextKey, srv)</div><div class="line">	ctx = context.WithValue(ctx, LocalAddrContextKey, l.Addr())</div><div class="line">	for &#123;</div><div class="line">		// 监听请求，</div><div class="line">		rw, e := l.Accept()</div><div class="line">		if e != nil &#123;</div><div class="line">			if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</div><div class="line">				...</div><div class="line">				continue</div><div class="line">			&#125;</div><div class="line">			return e</div><div class="line">		&#125;</div><div class="line">		tempDelay = 0</div><div class="line">		// 创建一个连接</div><div class="line">		c := srv.newConn(rw)</div><div class="line">		c.setState(c.rwc, StateNew) // before Serve can return</div><div class="line">		// 开启一个goroutines处理这个请求</div><div class="line">		go c.serve(ctx)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">func (c *conn) serve(ctx context.Context) &#123;</div><div class="line">	...</div><div class="line">	for &#123;</div><div class="line">		// 这个过程会根据Context生成http.Response对象</div><div class="line">		w, err := c.readRequest(ctx)</div><div class="line">		if c.r.remain != c.server.initialReadLimitSize() &#123;</div><div class="line">			// If we read any bytes off the wire, we&apos;re active.</div><div class="line">			c.setState(c.rwc, StateActive)</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		...</div><div class="line"></div><div class="line">		// c.server就是BeeApp.Server</div><div class="line">		// BeeApp.Server上绑定了Beego自定义的路由操作</div><div class="line">		// 即BeeApp.Server.Handler = ControllerRegister</div><div class="line">		serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) &#123;</div><div class="line">	// 这里handler就是Beego中的ControllerRegister类型</div><div class="line">	handler := sh.srv.Handler</div><div class="line">	if handler == nil &#123;</div><div class="line">		// 默认是DefaultServeMux</div><div class="line">		handler = DefaultServeMux</div><div class="line">	&#125;</div><div class="line">	if req.RequestURI == &quot;*&quot; &amp;&amp; req.Method == &quot;OPTIONS&quot; &#123;</div><div class="line">		handler = globalOptionsHandler&#123;&#125;</div><div class="line">	&#125;</div><div class="line">	// 调用ServeHTTP处理，并传入http.ResponseWriter，http.Request两个参数</div><div class="line">	handler.ServeHTTP(rw, req)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在啰嗦几句，这个流程中所有的http.Server{}对象都是beego.BeeApp.Server，只不过经过go的几经周折，在func (c *conn) serve(ctx context.Context){}方法中的serverHandler{c.server}.ServeHTTP(w, w.req)这条语句传递给serverHandle{}结构体，又在func (sh serverHandler) ServeHTTP(rw, req){}方法中，handler := sh.srv.Handler这条语句就获得了beego.ControllerRegister实例，最终调用了beego.ControllerRegister.ServeHTTP(rw, req)来处理路由，最终转发到相应的控制器中，继而视图展示或者返回数据。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;beego-ControllerRegister&quot;&gt;&lt;a href=&quot;#beego-ControllerRegister&quot; class=&quot;headerlink&quot; title=&quot;beego.ControllerRegister&quot;&gt;&lt;/a&gt;beego.ControllerRegister&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这里主要是讲了beego如何将自定义路由处理传递给http.Server.Hanlder字段的，并且理解Go内部是如何调用ControllerRegister.ServeHTTP()方法的。具体深入到ControllerRegister是如何处理路由的，有待进一步学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在beego包中的app.go文件中定义了一个init()函数，这个方法就干了一件事情，就是创建一个App，赋值给一个全局可导出的BeeApp变量，App结构如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;type App struct &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	Handlers *ControllerRegister&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	Server   *http.Server&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中http.Server{}有个字段是Handler类型，这个Handler是一个接口里面只有一个函数声明，即：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;type Handler interface &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	ServeHTTP(ResponseWriter, *Request)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="go,beego" scheme="https://ofttryaj.github.io/tags/go-beego/"/>
    
  </entry>
  
  <entry>
    <title>Yii2启动流程</title>
    <link href="https://ofttryaj.github.io/2016/12/21/Yii2%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>https://ofttryaj.github.io/2016/12/21/Yii2启动流程/</id>
    <published>2016-12-21T07:40:16.000Z</published>
    <updated>2016-12-21T07:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Yii2启动流程"><a href="#Yii2启动流程" class="headerlink" title="Yii2启动流程"></a>Yii2启动流程</h1><p>通过上次的Yii2开发环境搭建的目录结构介绍，暴露给外界web目录，该目录下有一个index.php入口文件，那么所有的请求都是从这个入口文件开始的。具体来看看入口文件的代码。</p>
<blockquote>
<p><strong>这里我们只说到Application的实例化过程，具体run这一过程会专门说的。</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">// 我们在对项目进行init的时候，选择的是开发环境，因此debug为ture，env为dev</div><div class="line">defined(&apos;YII_DEBUG&apos;) or define(&apos;YII_DEBUG&apos;, true);</div><div class="line">defined(&apos;YII_ENV&apos;) or define(&apos;YII_ENV&apos;, &apos;dev&apos;);</div><div class="line"></div><div class="line">// 引入composer的自动加载文件</div><div class="line">require(__DIR__ . &apos;/../../vendor/autoload.php&apos;);</div><div class="line">// 引入了Yii2的启动文件，这个文件做了以下几件事情</div><div class="line">// 1. 注册了Yii2自动加载机制，并优先使用Yii2自动加载机制</div><div class="line">// 2. 引入了classes.php文件，限定名称 =&gt; 类的物理路径之间的映射关系</div><div class="line">// 3. Yii::$container，实例化这个依赖注入容器，在一次请求过程中，这个属性是全局唯一的，这个依赖注入容器以后会详细说明</div><div class="line">require(__DIR__ . &apos;/../../vendor/yiisoft/yii2/Yii.php&apos;);</div><div class="line">// 这个文件会向Yii::$aliases追加@common,@frontend,@backend,@console</div><div class="line">// 与之相对应的物理路径，当然我们也可以根据需要添加相应的映射</div><div class="line">require(__DIR__ . &apos;/../../common/config/bootstrap.php&apos;);</div><div class="line">// 与上面的文件功能一致，这个是各自应用独有的，上面是每个应用公用的</div><div class="line">require(__DIR__ . &apos;/../config/bootstrap.php&apos;);</div><div class="line"></div><div class="line">// 整理出yii\web\Application类所需要的格式的配置</div><div class="line">// 从这几个合并的顺序可以看出，应用下的配置会覆盖公共配置</div><div class="line">// -local.php会覆盖.php配置</div><div class="line">$config = yii\helpers\ArrayHelper::merge(</div><div class="line">    require(__DIR__ . &apos;/../../common/config/main.php&apos;),</div><div class="line">    require(__DIR__ . &apos;/../../common/config/main-local.php&apos;),</div><div class="line">    require(__DIR__ . &apos;/../config/main.php&apos;),</div><div class="line">    require(__DIR__ . &apos;/../config/main-local.php&apos;)</div><div class="line">);</div><div class="line"></div><div class="line">// 实例化web application实例</div><div class="line">$application = new yii\web\Application($config);</div><div class="line">// 运行，就是这么优美地运行起来了</div><div class="line">$application-&gt;run();</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>在了解yii\web\Application实例化过程之前，我们先看看yii Application类都继承了哪些基类，首先Application类也分两大类：</p>
<ol>
<li>yii\console\Application</li>
<li>yii\web\Application</li>
</ol>
<p>这两个类都继承了<strong>yii\base\Application</strong>，这个类是一个抽象类，目前知道这些就OK了，base Application集成了<strong>yii\base\Module</strong>，继续往下走，base Module继承了<strong>yii\di\ServiceLocator</strong>，di ServiceLocator继承了<strong>yii\base\Component</strong>，最后base Component继承了<strong>yii\base\Ojbect</strong>，在yii框架中这是所有类的基类，那么连起来就是这样的，我用箭头来表示继承关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yii\web\Application -&gt;yii\base\Application-&gt;yii\base\Module -&gt;yii\di\ServiceLocator -&gt;yii\base\Component -&gt;yii\base\Object</div></pre></td></tr></table></figure>
<p>当运行到new yii\web\Application($config)的时候，我们了解了类的继承关系之后，就知道会调用yii\base\Application类的构造方法，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public function __construct($config = [])</div><div class="line">&#123;</div><div class="line">	// 这里Yii静态属性$app的就是当前运行的yii\web\Application实例</div><div class="line">    Yii::$app = $this;</div><div class="line">    static::setInstance($this);</div><div class="line"></div><div class="line">    $this-&gt;state = self::STATE_BEGIN;</div><div class="line">	// 对$config进行处理，以下会说到具体做了什么</div><div class="line">    $this-&gt;preInit($config);</div><div class="line">	// 注册错误处理机制</div><div class="line">    $this-&gt;registerErrorHandler($config);</div><div class="line"></div><div class="line">	// 这里跳过了Module的构造方法，而是直接调用了Object的构造方法</div><div class="line">    Component::__construct($config);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>yii\base\Ojbect的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 这个方法很简单，就是传入一个数组，或者什么都不传入，如果这个数组不为空，则调用</div><div class="line">// Yii::configure($this, $config)方法，在这里$this即为yii\web\Application的一个实例</div><div class="line">// 接下来调用init()方法</div><div class="line">public function __construct($config = [])</div><div class="line">&#123;</div><div class="line">    if (!empty($config)) &#123;</div><div class="line">        Yii::configure($this, $config);</div><div class="line">    &#125;</div><div class="line">    $this-&gt;init();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Yii::configure()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 这里的$object就是上面说的$this，这里给$object的$name属性赋值$value</div><div class="line">// 那么$object可能不存在$name属性，这里yii框架应用了PHP的模式方法__set()方法</div><div class="line">// 当$name属性不存在时，则会自动调用__set()方法，这个方法在yii\base\Component类中定义了，这里就我们就不详细讨论这个方法，我只要知道，如果定义了$name的setter方法就调用这个setter方法</div><div class="line">public static function configure($object, $properties)</div><div class="line">&#123;</div><div class="line">    foreach ($properties as $name =&gt; $value) &#123;</div><div class="line">        $object-&gt;$name = $value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return $object;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>既然是启动，我们通过运行时能知道$properties这个数组的数组结构，我们只要知道结构，具体内容<a href="http://aj.gitgang.com/?p=96" target="_blank" rel="external">可以参照yii2配置详解</a>，结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">	// [vendorPath] =&gt; &apos;vendorPath&apos;,</div><div class="line">	[components] =&gt; [一个一个组件],</div><div class="line">	[id] =&gt; &apos;应用ID&apos;,</div><div class="line">	// [basePath] =&gt; &apos;应用根目录&apos;,</div><div class="line">	[bootstrap] =&gt; [],</div><div class="line">	[controllerNamespace] =&gt; &apos;控制器命名空间&apos;,</div><div class="line">	[params] =&gt; &apos;配置参数&apos;,</div><div class="line">	[modules] =&gt; [一个一个模块]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>这个结构就是通过yii\helpers\ArrayHelper::merge()合并之后的配置，但是之后，被yii\base\Appliction-&gt;preInit()方法处理，若存在，则去掉数组的basePath，vendorPath，runtimePath，timeZone这些索引。（以上注释了的就表示去掉了），preInit()除了做了以上操作，还对配置文件配置的components跟web application和base application内置的核心组件进行了合并，合并规则是这样的，若配置文件不存在内置的组件，则直接追加到$config组件相应的部分，若存在，但是没有设置class索引，则把内置组件class赋值给相应的组件class。</p>
<p>在知道了$properties数据结构之后，我们在回到Yii::configure()方法，对$properties进行遍历：</p>
<ol>
<li>当遍历到components时，会调用yii\di\ServiceLocator-&gt;setComponents(),这个方法会通过ServiceLocator-&gt;set()方法把我们刚刚合并好的组件一个一个的注册到yii\di\ServiceLocator-&gt;_definitions属性，这个类还有另一个属性_components,当通过ServiceLocator-&gt;get()方法获取组件实例的时候会往_components属性追加组件实例；</li>
<li>当遍历到id，bootstrap，controllerNamespace，params这些因为Application均有这些属性，因此直接赋值</li>
<li>当遍历到modules时，则会调用yii\base\Module-&gt;setModules()方法，这个方法会通过yii\base\Module-&gt;setModule()往yii\base\Module-&gt;_moudles属性追加模块，同样也可以通过yii\base\Module-&gt;getModule()来获取模块，与此同时，如果获取的不是一个yii\base\Module实例则会进行实例化，实例化之后会通过yii\base\Module-&gt;setInstance()方法追加到Yii::$app-&gt;loadedModules[get_class($instance)] = $instance</li>
</ol>
<p>到这里一个yii\web\Application实例就完成了，接下来就是调用init()方法了，我们通过类的继承关系知道，yii\base\Application重写了yii\base\Object的init方法，这个方法调用yii\web\Applicatin-&gt;bootstrap()方法，这个bootstrap方法，设置了两个@webroot和@web两个别名，直接就调用了yii\base\Application-&gt;bootstrap()方法，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">protected function bootstrap()</div><div class="line">&#123;</div><div class="line">    if ($this-&gt;extensions === null) &#123;</div><div class="line">    	// 得到的就是你的yii框架的$vendorPath/yiisoft/extensions.php</div><div class="line">    	// 具体有什么内容可以去看看，$vendorPath就是你的vendor目录路径</div><div class="line">        $file = Yii::getAlias(&apos;@vendor/yiisoft/extensions.php&apos;);</div><div class="line">        // 这个PHP文件就返回一个数组</div><div class="line">        $this-&gt;extensions = is_file($file) ? include($file) : [];</div><div class="line">    &#125;</div><div class="line">    // 遍历每一个扩展</div><div class="line">    foreach ($this-&gt;extensions as $extension) &#123;</div><div class="line">        if (!empty($extension[&apos;alias&apos;])) &#123;</div><div class="line">            foreach ($extension[&apos;alias&apos;] as $name =&gt; $path) &#123;</div><div class="line">            	// 若存在别名索引，则向Yii追加一个别名以及目录路径的映射</div><div class="line">                Yii::setAlias($name, $path);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 若存在bootstrap索引，则实例化组件</div><div class="line">        if (isset($extension[&apos;bootstrap&apos;])) &#123;</div><div class="line">            $component = Yii::createObject($extension[&apos;bootstrap&apos;]);</div><div class="line">            // 若组件实现了BootstrapInterface接口，则调用bootstrap()方法启动</div><div class="line">            if ($component instanceof BootstrapInterface) &#123;</div><div class="line">                Yii::trace(&apos;Bootstrap with &apos; . get_class($component) . &apos;::bootstrap()&apos;, __METHOD__);</div><div class="line">                $component-&gt;bootstrap($this);</div><div class="line">            &#125; else &#123;</div><div class="line">                Yii::trace(&apos;Bootstrap with &apos; . get_class($component), __METHOD__);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    foreach ($this-&gt;bootstrap as $class) &#123;</div><div class="line">        $component = null;</div><div class="line">        if (is_string($class)) &#123;</div><div class="line">            // yii\di\ServiceLocator-&gt;has()方法从当前类的两个属性判断是否存在</div><div class="line">            // 即_components和_definitions</div><div class="line">            if ($this-&gt;has($class)) &#123;</div><div class="line">            	// 若存在属性中，则调用yii\di\ServiceLocator-&gt;get()获取</div><div class="line">                $component = $this-&gt;get($class);</div><div class="line">            &#125; elseif ($this-&gt;hasModule($class)) &#123;</div><div class="line">            	// 调用yii\base\Module-&gt;hasModule()方法判断是否存在</div><div class="line">                //  若存在则调用yii\base\Module-&gt;getModule()获取</div><div class="line">                $component = $this-&gt;getModule($class);</div><div class="line">            &#125; elseif (strpos($class, &apos;\\&apos;) === false) &#123;</div><div class="line">                throw new InvalidConfigException(&quot;Unknown bootstrapping component ID: $class&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 若$component为null，则直接调用Yii::createOjbect()方法直接创建</div><div class="line">        if (!isset($component)) &#123;</div><div class="line">            $component = Yii::createObject($class);</div><div class="line">        &#125;</div><div class="line">		// 若$component实现了BootstrapInterface接口则启动</div><div class="line">        if ($component instanceof BootstrapInterface) &#123;</div><div class="line">            Yii::trace(&apos;Bootstrap with &apos; . get_class($component) . &apos;::bootstrap()&apos;, __METHOD__);</div><div class="line">            $component-&gt;bootstrap($this);</div><div class="line">        &#125; else &#123;</div><div class="line">            Yii::trace(&apos;Bootstrap with &apos; . get_class($component), __METHOD__);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>至此，一个可运行的Application实例以及一些额外的扩展已经完全就绪了。这里还有处理错误机制没有仔细说，这个就是调用PHP函数注册yii2自定义的错误处理机制，这些就很简单了，这里篇幅有限就不再啰嗦了。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Yii2启动流程&quot;&gt;&lt;a href=&quot;#Yii2启动流程&quot; class=&quot;headerlink&quot; title=&quot;Yii2启动流程&quot;&gt;&lt;/a&gt;Yii2启动流程&lt;/h1&gt;&lt;p&gt;通过上次的Yii2开发环境搭建的目录结构介绍，暴露给外界web目录，该目录下有一个index.php入口文件，那么所有的请求都是从这个入口文件开始的。具体来看看入口文件的代码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;这里我们只说到Application的实例化过程，具体run这一过程会专门说的。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// 我们在对项目进行init的时候，选择的是开发环境，因此debug为ture，env为dev&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;defined(&amp;apos;YII_DEBUG&amp;apos;) or define(&amp;apos;YII_DEBUG&amp;apos;, true);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;defined(&amp;apos;YII_ENV&amp;apos;) or define(&amp;apos;YII_ENV&amp;apos;, &amp;apos;dev&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 引入composer的自动加载文件&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;require(__DIR__ . &amp;apos;/../../vendor/autoload.php&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 引入了Yii2的启动文件，这个文件做了以下几件事情&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 1. 注册了Yii2自动加载机制，并优先使用Yii2自动加载机制&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 2. 引入了classes.php文件，限定名称 =&amp;gt; 类的物理路径之间的映射关系&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 3. Yii::$container，实例化这个依赖注入容器，在一次请求过程中，这个属性是全局唯一的，这个依赖注入容器以后会详细说明&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;require(__DIR__ . &amp;apos;/../../vendor/yiisoft/yii2/Yii.php&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 这个文件会向Yii::$aliases追加@common,@frontend,@backend,@console&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 与之相对应的物理路径，当然我们也可以根据需要添加相应的映射&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;require(__DIR__ . &amp;apos;/../../common/config/bootstrap.php&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 与上面的文件功能一致，这个是各自应用独有的，上面是每个应用公用的&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;require(__DIR__ . &amp;apos;/../config/bootstrap.php&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 整理出yii\web\Application类所需要的格式的配置&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 从这几个合并的顺序可以看出，应用下的配置会覆盖公共配置&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// -local.php会覆盖.php配置&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$config = yii\helpers\ArrayHelper::merge(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    require(__DIR__ . &amp;apos;/../../common/config/main.php&amp;apos;),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    require(__DIR__ . &amp;apos;/../../common/config/main-local.php&amp;apos;),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    require(__DIR__ . &amp;apos;/../config/main.php&amp;apos;),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    require(__DIR__ . &amp;apos;/../config/main-local.php&amp;apos;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 实例化web application实例&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$application = new yii\web\Application($config);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 运行，就是这么优美地运行起来了&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$application-&amp;gt;run();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="PHP,Yii2" scheme="https://ofttryaj.github.io/tags/PHP-Yii2/"/>
    
  </entry>
  
  <entry>
    <title>Yii2开发环境搭建</title>
    <link href="https://ofttryaj.github.io/2016/12/21/Yii2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://ofttryaj.github.io/2016/12/21/Yii2环境搭建/</id>
    <published>2016-12-21T07:40:16.000Z</published>
    <updated>2016-12-21T08:18:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Yii2开发环境搭建"><a href="#Yii2开发环境搭建" class="headerlink" title="Yii2开发环境搭建"></a>Yii2开发环境搭建</h1><p>官方提供的目录架构<a href="https://github.com/yiisoft/yii2-app-advanced" target="_blank" rel="external">yii2-app-advance</a>|<a href="https://github.com/yiisoft/yii2-app-basic" target="_blank" rel="external">yii2-app-basice</a>下载release包。</p>
<p>或者可以利用<a href="http://www.phpcomposer.com/" target="_blank" rel="external">composer</a>管理工具来创建项目，yii2依赖composer-asset-plugin插件，因此必须先安装这个插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">这里采用全局安装，具有全局性。</div><div class="line">composer global require &quot;fxp/composer-asset-plugin:~1.1.1&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">composer create-project yiisoft/yii2-app-basic basic 2.0.9</div><div class="line">or</div><div class="line">composer create-project yiisoft/yii2-app-advanced advanced 2.0.9</div></pre></td></tr></table></figure>
<p>若是下载了官方的包，还需要经过一个步骤,进入到你的项目目录，执行下面的命令，进行安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">composer install</div></pre></td></tr></table></figure>
<p>这个过程可能会很漫长，国外的资源，建议翻墙。</p>
<a id="more"></a>
<p>接下来还需要做一个操作，初始化yii2项目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">./init</div><div class="line">Yii Application Initialization Tool v1.0</div><div class="line"></div><div class="line">Which environment do you want the application to be initialized in?</div><div class="line"></div><div class="line">  [0] Development</div><div class="line">  [1] Production</div><div class="line"></div><div class="line">  Your choice [0-1, or &quot;q&quot; to quit]</div></pre></td></tr></table></figure>
<p>这有两个选项，0表示开发环境，1表示生产环境。我们本地开发的话，则选0，若线上环境则选择1，这里我们选0，选了0之后，会提示你</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Initialize the application under &apos;Development&apos; environment? [yes|no]</div></pre></td></tr></table></figure>
<p>输入yes，看到如下的提示表明我们安装成功了，接下来就是配置Nginx/Apache环境。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Start initialization ...</div><div class="line"></div><div class="line">   generate backend/config/main-local.php</div><div class="line">   generate backend/config/params-local.php</div><div class="line">   generate backend/web/index-test.php</div><div class="line">   generate backend/web/index.php</div><div class="line">   generate common/config/main-local.php</div><div class="line">   generate common/config/params-local.php</div><div class="line">   generate console/config/main-local.php</div><div class="line">   generate console/config/params-local.php</div><div class="line">   generate frontend/config/main-local.php</div><div class="line">   generate frontend/config/params-local.php</div><div class="line">   generate frontend/web/index-test.php</div><div class="line">   generate frontend/web/index.php</div><div class="line">   generate tests/codeception/config/config-local.php</div><div class="line">   generate yii</div><div class="line">   generate cookie validation key in backend/config/main-local.php</div><div class="line">   generate cookie validation key in frontend/config/main-local.php</div><div class="line">      chmod 0777 backend/runtime</div><div class="line">      chmod 0777 backend/web/assets</div><div class="line">      chmod 0777 frontend/runtime</div><div class="line">      chmod 0777 frontend/web/assets</div><div class="line">      chmod 0755 yii</div><div class="line">      chmod 0755 tests/codeception/bin/yii</div><div class="line"></div><div class="line">  ... initialization completed.</div></pre></td></tr></table></figure>
<h3 id="Application-structure"><a href="#Application-structure" class="headerlink" title="Application structure"></a>Application structure</h3><p>这里我们只针对yii2-app-advance模板，advance目录结构(这里只列举了我们经常用的)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">backend  ------------- web应用后台</div><div class="line">common   ------------- 公共配置或者一些服务</div><div class="line">console  ------------- 控制台，在项目根目录执行./yii可以看到很多帮助选项，也允许开发者开发自己的命令</div><div class="line">frontend ------------- web应用前台</div></pre></td></tr></table></figure>
<p>前台与后台目录结构是一致的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">assets      ------------ 前端资源管理包</div><div class="line">config      ------------ 应用独立配置项</div><div class="line">controllers ------------ 控制器</div><div class="line">models      ------------ model层</div><div class="line">runtime     ------------ 运行时缓存数据</div><div class="line">views       ------------ 视图层</div><div class="line">web         ------------ 这个是唯一暴露给外界的目录</div></pre></td></tr></table></figure>
<p>console目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">config      ------------ console应用独立配置项</div><div class="line">controllers ------------ 控制器</div><div class="line">migrations  ------------ 数据库迁移文件</div><div class="line">models      ------------ model层</div><div class="line">runtime     ------------ 运行时缓存文件</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Yii2开发环境搭建&quot;&gt;&lt;a href=&quot;#Yii2开发环境搭建&quot; class=&quot;headerlink&quot; title=&quot;Yii2开发环境搭建&quot;&gt;&lt;/a&gt;Yii2开发环境搭建&lt;/h1&gt;&lt;p&gt;官方提供的目录架构&lt;a href=&quot;https://github.com/yiisoft/yii2-app-advanced&quot;&gt;yii2-app-advance&lt;/a&gt;|&lt;a href=&quot;https://github.com/yiisoft/yii2-app-basic&quot;&gt;yii2-app-basice&lt;/a&gt;下载release包。&lt;/p&gt;
&lt;p&gt;或者可以利用&lt;a href=&quot;http://www.phpcomposer.com/&quot;&gt;composer&lt;/a&gt;管理工具来创建项目，yii2依赖composer-asset-plugin插件，因此必须先安装这个插件：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这里采用全局安装，具有全局性。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;composer global require &amp;quot;fxp/composer-asset-plugin:~1.1.1&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;composer create-project yiisoft/yii2-app-basic basic 2.0.9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;or&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;composer create-project yiisoft/yii2-app-advanced advanced 2.0.9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;若是下载了官方的包，还需要经过一个步骤,进入到你的项目目录，执行下面的命令，进行安装：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;composer install&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个过程可能会很漫长，国外的资源，建议翻墙。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP,Yii2" scheme="https://ofttryaj.github.io/tags/PHP-Yii2/"/>
    
  </entry>
  
  <entry>
    <title>Yii2配置详解</title>
    <link href="https://ofttryaj.github.io/2016/12/21/Yii2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>https://ofttryaj.github.io/2016/12/21/Yii2配置文件/</id>
    <published>2016-12-21T07:40:16.000Z</published>
    <updated>2016-12-21T07:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Yii2配置详解"><a href="#Yii2配置详解" class="headerlink" title="Yii2配置详解"></a>Yii2配置详解</h1><p>yii2的配置文件除了公共(common文件夹下的配置)，每个应用目录下都有自己的配置文件，这些配置均包含以下几个文件：(我们这里用的是Yii2官方的高级模板)</p>
<blockquote>
<p><strong>后面还会说到Yii::createObject()方法，因为跟配置有点联系，所以就放在这里</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">main-local.php           ---------- 本地的配置，本地开发需要自己特定的配置，可以覆盖main.php中的配置项</div><div class="line">main.php                 ---------- 正式环境的配置项</div><div class="line">params-local.php         ---------- 本地的参数配置</div><div class="line">params.php               ---------- 正式环境的参数配置</div><div class="line">bootstrap.php            ---------- 设置 aliasName =&gt; 物理路径 映射，比如：@common =&gt; &apos;/Users/llrve/workspaces/php/yii/common&apos;，这里只是为了说明这个文件的作用，物理路径不会这样写死。</div></pre></td></tr></table></figure>
<p>通常*-local.php这类文件都不会加入版本控制，一般都是自己本地开发个性化的配置，比如数据连接配置项，每个人的数据库用户名，密码可能不相同，这里就可以在-local.php文件中配置自己的数据库配置选项。这些文件的优先顺序，可以从入口文件得知：</p>
<ol>
<li>应用的main-local.php会覆盖应用的main.php</li>
<li>应用的main.php会覆盖公共的main-local.php</li>
<li>公共的main-local.php会覆盖公共的main.php</li>
</ol>
<a id="more"></a>
<p>params配置文件同main文件的合并顺序</p>
<p>以上所有的配置文件经合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$config = yii\helpers\ArrayHelper::merge(</div><div class="line">    require(__DIR__ . &apos;/../../common/config/main.php&apos;),</div><div class="line">    require(__DIR__ . &apos;/../../common/config/main-local.php&apos;),</div><div class="line">    require(__DIR__ . &apos;/../config/main.php&apos;),</div><div class="line">    require(__DIR__ . &apos;/../config/main-local.php&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>合并之后的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">Array</div><div class="line">(</div><div class="line">    [vendorPath] =&gt; /Users/llrve/workspaces/php/yii/vendor</div><div class="line">    [components] =&gt; Array</div><div class="line">        (</div><div class="line">				[db] =&gt; Array</div><div class="line">                (</div><div class="line">                    [class] =&gt; yii\db\Connection</div><div class="line">                    [dsn] =&gt; mysql:host=localhost;dbname=yii2advanced</div><div class="line">                    [username] =&gt; root</div><div class="line">                    [password] =&gt;</div><div class="line">                    [charset] =&gt; utf8</div><div class="line">                )</div><div class="line">              ...这里我只列举了db组件，还有像mailer，log等等或者你自己定义的组件</div><div class="line">        )</div><div class="line"></div><div class="line">    [id] =&gt; app-frontend</div><div class="line">    [basePath] =&gt; /Users/llrve/workspaces/php/yii/frontend</div><div class="line">    [bootstrap] =&gt; Array</div><div class="line">        (</div><div class="line">            [0] =&gt; log</div><div class="line">            [1] =&gt; debug</div><div class="line">            [2] =&gt; gii</div><div class="line">        )</div><div class="line"></div><div class="line">    [controllerNamespace] =&gt; frontend\controllers</div><div class="line">    [params] =&gt; Array</div><div class="line">        (</div><div class="line">        	配置参数，这个用来扩展main配置，可以将一些公用的参数配置在这个文件中</div><div class="line">            [adminEmail] =&gt; admin@example.com</div><div class="line">            [supportEmail] =&gt; support@example.com</div><div class="line">            [user.passwordResetTokenExpire] =&gt; 3600</div><div class="line">        )</div><div class="line"></div><div class="line">    [modules] =&gt; Array</div><div class="line">        (</div><div class="line">        	这里都是yii框架的一个扩展模块，debug，gii都是内置的，我们也可以利用gii创建自己的模块</div><div class="line">            [debug] =&gt; Array</div><div class="line">                (</div><div class="line">                    [class] =&gt; yii\debug\Module</div><div class="line">                )</div><div class="line"></div><div class="line">            [gii] =&gt; Array</div><div class="line">                (</div><div class="line">                    [class] =&gt; yii\gii\Module</div><div class="line">                )</div><div class="line"></div><div class="line">        )</div><div class="line"></div><div class="line">)</div></pre></td></tr></table></figure>
<p>合成之后的整体结构是这样的。也会有自定义的组件和模块。了解了配置格式之后，我们再来看看yii框架是如何根据这些配置去实例化一个类。yii\BaseYii类中定义了一个createObject()方法：</p>
<blockquote>
<p><strong>yii\BaseYii::$container就是yii\di\Container的实例，这里我们主要是了解下yii\BaseYii::createOjbect()方法需要的数据结构，具体Container如何利用反射得到一个对象，有兴趣的可以自己深入了解</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static function createObject($type, array $params = [])</div><div class="line">&#123;</div><div class="line">    if (is_string($type)) &#123;</div><div class="line">    	// 如果是字符串直接yii\di\Container-&gt;get()方法，此处$params为构造方法需要的参数值</div><div class="line">        return static::$container-&gt;get($type, $params);</div><div class="line">    &#125; elseif (is_array($type) &amp;&amp; isset($type[&apos;class&apos;])) &#123;</div><div class="line">        // 如果是数组，并且有class索引，则获取class的值，并且unset class索引</div><div class="line">        $class = $type[&apos;class&apos;];</div><div class="line">        unset($type[&apos;class&apos;]);</div><div class="line">        // $class为类名，$params为构造方法需要的参数，$type为$class属性</div><div class="line">        return static::$container-&gt;get($class, $params, $type);</div><div class="line">    &#125; elseif (is_callable($type, true)) &#123;</div><div class="line">    	// 如果$type是一个可调用结构，则直接调用invoke</div><div class="line">    	// is_callable(functionName)或者is_callable([object, method])</div><div class="line">        return static::$container-&gt;invoke($type, $params);</div><div class="line">    &#125; elseif (is_array($type)) &#123;</div><div class="line">        throw new InvalidConfigException(&apos;Object configuration must be an array containing a &quot;class&quot; element.&apos;);</div><div class="line">    &#125; else &#123;</div><div class="line">        throw new InvalidConfigException(&apos;Unsupported configuration type: &apos; . gettype($type));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过以上，我们知道了给Yii::createObject()方法如何传入参数了，我们可以有以下几种调用形式：</p>
<blockquote>
<p><strong>这里是引用了官方的demo</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// create an object using a class name</div><div class="line"> $object = Yii::createObject(&apos;yii\db\Connection&apos;);</div><div class="line"></div><div class="line">// create an object using a configuration array</div><div class="line">$object = Yii::createObject([</div><div class="line">  	&apos;class&apos; =&gt; &apos;yii\db\Connection&apos;,</div><div class="line">  	&apos;dsn&apos; =&gt; &apos;mysql:host=127.0.0.1;dbname=demo&apos;,</div><div class="line">  	&apos;username&apos; =&gt; &apos;root&apos;,</div><div class="line">  	&apos;password&apos; =&gt; &apos;&apos;,</div><div class="line">  	&apos;charset&apos; =&gt; &apos;utf8&apos;,</div><div class="line">]);</div><div class="line"></div><div class="line">// create an object with two constructor parameters</div><div class="line">$object = \Yii::createObject(&apos;MyClass&apos;, [$param1, $param2]);</div></pre></td></tr></table></figure>
<p>yii2框架的配置文件格式跟第二种调用方式的数据结构一致这样我们就知道了配置components为什么要这样配置了，我们说明下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">	&apos;class&apos; =&gt; &apos;类名&apos;,</div><div class="line">	&apos;property1&apos; =&gt; &apos;属性值1&apos;,</div><div class="line">	&apos;property2&apos; =&gt; &apos;属性值2&apos;,</div><div class="line">	...</div><div class="line">]</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Yii2配置详解&quot;&gt;&lt;a href=&quot;#Yii2配置详解&quot; class=&quot;headerlink&quot; title=&quot;Yii2配置详解&quot;&gt;&lt;/a&gt;Yii2配置详解&lt;/h1&gt;&lt;p&gt;yii2的配置文件除了公共(common文件夹下的配置)，每个应用目录下都有自己的配置文件，这些配置均包含以下几个文件：(我们这里用的是Yii2官方的高级模板)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;后面还会说到Yii::createObject()方法，因为跟配置有点联系，所以就放在这里&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;main-local.php           ---------- 本地的配置，本地开发需要自己特定的配置，可以覆盖main.php中的配置项&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;main.php                 ---------- 正式环境的配置项&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;params-local.php         ---------- 本地的参数配置&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;params.php               ---------- 正式环境的参数配置&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;bootstrap.php            ---------- 设置 aliasName =&amp;gt; 物理路径 映射，比如：@common =&amp;gt; &amp;apos;/Users/llrve/workspaces/php/yii/common&amp;apos;，这里只是为了说明这个文件的作用，物理路径不会这样写死。&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通常*-local.php这类文件都不会加入版本控制，一般都是自己本地开发个性化的配置，比如数据连接配置项，每个人的数据库用户名，密码可能不相同，这里就可以在-local.php文件中配置自己的数据库配置选项。这些文件的优先顺序，可以从入口文件得知：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用的main-local.php会覆盖应用的main.php&lt;/li&gt;
&lt;li&gt;应用的main.php会覆盖公共的main-local.php&lt;/li&gt;
&lt;li&gt;公共的main-local.php会覆盖公共的main.php&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="PHP,Yii2" scheme="https://ofttryaj.github.io/tags/PHP-Yii2/"/>
    
  </entry>
  
  <entry>
    <title>beego启动流程-SESSION</title>
    <link href="https://ofttryaj.github.io/2016/12/21/beego%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-SESSION/"/>
    <id>https://ofttryaj.github.io/2016/12/21/beego启动流程-SESSION/</id>
    <published>2016-12-21T07:40:16.000Z</published>
    <updated>2016-12-21T08:17:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Beego-Session"><a href="#Beego-Session" class="headerlink" title="Beego Session"></a>Beego Session</h3><p>我们知道，beego在跑起来之前，调用了<strong>initBeforeHTTPRun()</strong>这个函数。beego定义了一个全局不可导出的变量<strong>hooks</strong>，这是一个切片，每个元素的类型是func() error，那么前面那个函数就往<strong>hooks</strong>切片中追加元素，追加完成之后，会遍历<strong>hooks</strong>切片，由于切片每一个元素都是函数类型，因此可以直接调用，<strong>hooks</strong>切片中有这些元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func registerMime() error</div><div class="line">func registerDefaultErrorHandler() error</div><div class="line">func registerSession() error</div><div class="line">func registerTemplate() error</div><div class="line">func registerAdmin() error</div><div class="line">func registerGzip() error</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>以上都是在beego包下的hooks.go定义的函数，类型均为func() error，我们先来了解下beego的session包下的session.go，这个文件中定义了一些抽象的需要具体实现的相关结构，定义的相关结构：</p>
<ul>
<li><p><strong>provides</strong>的类型为map[string]Provider，这个跟我们之前beego的配置有点像，就是在redis，file，memory,mysql等等还有一些其他的为存储介质的具体实现中，在init函数通过session.Register函数均已注册到<strong>provides</strong>变量中；</p>
</li>
<li><p>两个接口分别为Store和Provider，定义了一些行为。我们以session_file.go为例，以file为存储介质的实现，定义了两个结构体FileStore和FileProvider分别实现了Store和Provider接口；</p>
<ul>
<li><p>Store接口负责session数据的处理，定义了Set(),Get(),Delete(),SessionID(),SessionRelease(),Flush()操作；</p>
</li>
<li><p>Provider接口定义了session本身的管理行为，负责生产Store，定义了SessionInit(),SessionRead(),SessionExist(),SessionRegenerate(),SessionDestroy(),SessionAll(),SessionGC()操作；</p>
</li>
</ul>
</li>
<li><p>以上两个接口只定义了抽象行为，这些具体实现都在session包下的session_*.go文件中，不同的存储介质有不同的实现，这样说会很抽象，我们来看看seesion_file.go是如何实现这两个接口，看完之后，我们对Store和Provider接口的理解会更加深入；</p>
<ul>
<li><p>session_file.go中定义了FileSessionStore和FileProvider两个结构体，它们分别实现了哪个接口，从名字上我就能知道了。只不过不同的存储介质结构体结构有所不同，具体如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">type FileSessionStore struct &#123;</div><div class="line">	// session id 唯一</div><div class="line">	sid    string</div><div class="line">	// 读写保护</div><div class="line">	lock   sync.RWMutex</div><div class="line">	// 存储值，这时候并没有真操作文件，只有调用了Store.SessionRelease()方法，才真正操作文件</div><div class="line">	values map[interface&#123;&#125;]interface&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">type FileProvider struct &#123;</div><div class="line">	// 读写保护</div><div class="line">	lock        sync.RWMutex</div><div class="line">	// session有效时间</div><div class="line">	maxlifetime int64</div><div class="line">	// session存储路径，不同的实现这个含义不同，例如mysql的savePath指的是，连接mysql的源</div><div class="line">	// 即为：dbUserName:password@tcp(ip:port)DbName?charset=utf8</div><div class="line">	savePath    string</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>FileSessionStore方法具体实现：</p>
<ul>
<li>Set(key, value interface{}) error</li>
<li>Get(key interface{}) interface{}</li>
<li>Delete(key interface{}) error</li>
<li>Flush() error</li>
<li>SessionID() string</li>
<li><p>SessionRelease(w http.ResponseWriter)</p>
<p>前面4个方法都很简单，都是针对FileSessionStore结构体本身的操作，都是加锁，做完相应的操作，然后释放锁。SessionID()直接返回fs.sid，即sessionID；最后一个方法有点复杂，就是我们上面的操作增删查之后需要去更新文件中的内容，SessionRelease()方法就是做这个的：</p>
</li>
<li><p>首先会用EncodeGob()（session包下的一个编码函数对应解码的是DecodeGob）对fs.values进行编码；</p>
</li>
<li>接着会构造session文件的路径，规则(<strong>这个规则我们后面还会用到</strong>)是这样的，我们在SessionInit()中就传入了session根路径，在这个路径下，取fs.sid第一个字符和第二个字符最后连接上fs.sid，完整路径是这个：filepder.savePath/fs.sid[0]/fs.sid[1]/fs.sid(Linux环境下)，filepder是一个全局变量，下面我们会说到；</li>
<li>若以上的文件不存在，则创建；</li>
<li>之后会调用File相关方法，首先会清空文件内容，文件偏移量设置为0，将编码的数据写入文件，最后关闭文件；</li>
</ul>
</li>
<li><p>FileProvider方法具体实现：</p>
<ul>
<li>SessionInit(maxlifetime int64, savePath string) error<ul>
<li>filepder是一个全局变量，即filepder = &amp;FileProvider{}</li>
<li>这个方法就是初始化filepder这个变量，对filepder.maxlifetime = maxlifetime,filepder.savePath = savePath，这是FileProvider实例会注册到sessoin.providers变量中的；</li>
</ul>
</li>
<li>SessionRead(sid string) (Store, error)<ul>
<li>这个方法就是根据sessionID获取一个FileSessionStore实例，sid如何生成的之后会在session.Manager{}中看到；</li>
<li>按照我们上面说的session存储路径规则，即fp.savePath/sid[0]/sid[1]/sid，这个文件不存在则创建，紧接着会修改这个文件的访问和修改时间；</li>
<li>接下来调用ioutil.ReadAll(f)，把文件内容全部读入字节数组中；</li>
<li>若读出来的内容为空，则创建一个空的make(map[interface{}]interface{})赋值给kv作为FileSessionStore values字段的值；若不为空，上面存入的时候我对值做了EncodeGob()操作，那么反过来就应该解码，即调用DecodeGob()对读出的字节数组进行解码赋值给kv；</li>
<li>最后构造一个FileSessionStore实例，即&amp;FileSessionStore{sid: sid, values: kv}，返回；</li>
</ul>
</li>
<li>SessionExist(sid string) bool<ul>
<li>根据我们session存储路径的规则，根据os.Stat()返回的error类型的值是否为空，为空则说明不存在，否则存在；</li>
</ul>
</li>
<li>SessionDestroy(sid string) error<ul>
<li>删除相应的session存储文件；</li>
</ul>
</li>
<li>SeesionGC()<ul>
<li>gcmaxlifetime是一个全局变量，首先把fp.maxlifetime赋值给gcmaxliftime；</li>
<li>在fp.savePath即session存储根路径下，循坏用gcpath，gcpath是自定义的一个filepath.WalkFunc类型的函数，用来删除过期的session；</li>
<li>gcpath具体实现，如果遍历的路径是目录则不做任何处理，若是文件，则需要判断是否过期，判断过期的规则是，获取文件最后修改的时间，加上gcmaxfiletime，跟当前时间对比，如果小于当期那时间，则删除session存储文件；</li>
</ul>
</li>
<li>SessionAll() int<ul>
<li>跟GC类似，也是调用filepath.Walk(fp.save.Path, func() {})，只不过这里传入的是一个匿名函数来处理相应的逻辑；</li>
<li>a = &amp;activeSession{}，这个也是自定义的一个结构体，用来统计session的总个数；</li>
<li>调用a.viset()统计session存储根路径下有多少个文件；</li>
</ul>
</li>
<li>SessionRegenerate(oldsid, sid string) (Store, error)<ul>
<li>生成新的file session</li>
<li>这个需要创建oldsid和sid相关的文件，</li>
<li>若fp.savePath/sid[0]/sid[1]/sid文件存在则返回；</li>
<li>若存在fp.savePath/oldsid[0]/oldsid[1]/oldsid，则把内容拷贝到fp.savePath/sid[0]/sid[1]/sid文件中；</li>
<li>接下来会删除fp.savePath/oldsid[0]/oldsid[1]/oldsid文件，修改fp.savePath/sid[0]/sid[1]/sid文件的最后访问和修改时间；</li>
<li>ioutil.ReadAll(fp.savePath/sid[0]/sid[1]/sid)读到字节数组中，若为空则创建一个空的make(map[interface{}]interface{})赋值给kv，否则DecodeGob()赋值给kv，最后返回&amp;FileSessionStore{sid: sid, values: kv}；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>到这里我们session_file.go全部实现都说完了，其他的存储介质也都是类似的，有兴趣可以自己去了解。那么在这里就可以总结下Store和Provider的区别了</p>
<ol>
<li>Store定义都是对session数据的操作，Provider则定义了针对session本身的操作；</li>
<li>FileSessionStore定义了session的读，赋值，删除，更改，清空操作，针对Provider提供的session存储文件进行文件写操作；</li>
<li>FileProvider则提供了生成session存储文件，删除存储文件，重新生成存储文件，对过期的session回收；</li>
<li>因此Provider会生产Store，只有经过Provider生产的Store，才能对session的数据进行相关操作，若没有Provider，sessionStore也无从谈起，更别提对session数据操作；</li>
</ol>
</blockquote>
<ul>
<li><p>我们说回session.go文件，上面只说了两个接口，那么还定义了Manager和ManagerConfig两个结构体，</p>
<ul>
<li>ManagerConfig是Manager需要的配置项，Manager也依赖Provider具体实现，上面我们说了session_file.go的具体实现带着这个我们来看看Manager提供的方法；</li>
<li><p>接下来我们回到hooks.go的registerSession()函数实现</p>
<ul>
<li>首先判断配置项是否开启了session，若开启了则继续往下走；</li>
<li>conf := new(session.ManagerConfig)</li>
<li>优先读取应用配置文件app.conf中的sessionConfig，若存在则做相应的操作赋值给conf</li>
<li>若为空则读取BConfig相应的配置项赋值给相应的conf配置项</li>
<li>配置好了之后，调用session.NewManager(provider, conf)，这里的provider默认是memory，我们用file来代替，创建好的session.Manager赋值给GlobalSession(这个是在config.go文件中没有进行初始化的变量)全局变量。最后启用一个协程负责session过期的处理；<br>也就是在beego启动的时候，就会注册这些。</li>
</ul>
</li>
<li><p>通过上面我们知道了什么时候会实例化session.Manager(providerName, cf)了，那么我来看看session.NewManager()函数的具体实现：</p>
<ul>
<li>从<strong>providers</strong>全局变量中获取相应的provider，我们这里传入的是file，那么在session_file.go中调用Register()函数注册到了providers，也就是能取出&amp;session.FileProvider{}；</li>
<li>若cf.Maxlifetime == 0, 则cf.Maxlifetime = cf.Gclifetime；</li>
<li>若允许从http headers获取sessionID，则判断cf.SessionNameInHttpHeader这个格式是否符合标准，不符合则返回；</li>
<li>接下来会调用provider.SessionInit(cf.Maxlifetime, cf.ProviderConfig)，通过我们上面对file的SessionInit了解，就知道了，其实就是对session.FileProvider{}相关字段进行赋值，即filepder.maxlifetime = cf.Maxlifetime，filepder.savePath = cf.ProviderConfig，这里我就知道session的存储路径和有效时间都是在这里设置的；</li>
<li>最后返回&amp;Manager{provider, cf}</li>
</ul>
</li>
<li><p>在看看看Manager提供了那些可导出的方法</p>
<ul>
<li>SessionStart(w http.ResponseWriter, r *http.Request) (session Store, err error)<ul>
<li>这个方法在请求到来的时候都会请求到的，只有session启动了才能进行后续的相关的操作；</li>
<li>调用manager.getSid()这个方法是从请求中获取sessionID，若存在则，直接调用manager.provider.SessionRead()，通过前面我们了解到file的具体实现，SessionRead()就是根据sid创建相关的session存储文件，并返回一个可操作session的FileSessionStore对象；</li>
<li>若请求中没有sessionID，则调用manager.sessionID()，这个方法生成manager.config.SessionIDLength长度的随机串；</li>
<li>根据上面创建的sessionID，调用manager.provider.SessionRead(sid)，去的一个FileSessionStore实例赋值给session；</li>
<li>构造&amp;http.Cookie{}，Name字段赋值为manager.config.CookieName；Value赋值为url.QueryEscape(sid)，这个是对sid进行转码，便于sid安全的用在URL查询里；Path为”/“；HttpOnly为true；Secure为manager.isSecure(r)，这个方法先判断manager.config.Secure如果为false则直接返回false，若为true，则会判断http.Request相关字段；Domain赋值为manager.config.Domain；</li>
<li>manager.config.CookieLifeTime大于0的话，cookie.MaxAge = manager.config.CookieLifeTime，cookie.Expires赋值为当前时间加上CookieLiftTime；</li>
<li>manager.config.EnableSetCookie若为真，则把cookie放入响应头部；</li>
<li>接下来把cookie放入请求头中；</li>
<li>manager.config.EnableSidInHttpHeader为真，请求头和相应头都增加manager.config.SessionNameInHttpHeader = sid；</li>
<li>最后返回session；</li>
</ul>
</li>
<li>SessionDestroy(w http.ResponseWriter, r *http.Request)<ul>
<li>销毁session；</li>
<li>如果manager.config.EnableSidInHttpHeader为真，则去删除请求头和响应头manager.config.SessionNameInHttpHeader；</li>
<li>从请求头部获取名字为manager.config.CookieName的cookie，其实刚刚SessionStart()方法中我们构造的cookie放入请求头中，这里我们就能理解了；若这个cookie.Value为空，或者出错则直接返回；</li>
<li>其实这个cookie.Value就是经过url.QueryEscape(sid)的值，所以这里有反转回来，调用url.QueryUnescape(cookie.Value)；这样就拿到了sessionID；</li>
<li>有了sid之后，就可以调用manager.provider.SessionDestroy(sid)，本质上就是删除manager.config.ProviderConfig/sid[0]/sid[1]/sid这个文件；（filepder.savePath就是这里的ProviderConfig提供的）</li>
<li>如果manager.config.EnableSetCookie为真，需要让Name为manager.config.CookieName的cookie失效，因此这里cookie的Expires为当前时间，意思就是立即过期，然后放入响应头中；</li>
<li>这里整个session销毁过程就完成了；</li>
</ul>
</li>
<li>GetSessionStore(sid string) (sessions Store, err error)<ul>
<li>这个方法就简单了，就是调用manager.provider.SessionRead(sid)，这个方法上面也用到了，读取manager.config.ProviderConfig/sid[0]/sid[1]/sid中的内容，最终返回一个&amp;FileSessionStore；具体SessionRead()的实现可以看上面的介绍；</li>
</ul>
</li>
<li>GC()<ul>
<li>调用manager.provider.SessionGC()</li>
<li>我们在hooks.go中registerSession()函数中知道了，单独起了一个协程来对过期的session进行回收，这里用到了time.AfterFunc()，在manager.config.Gclifetime之间之后，就会调用自己，因为这个协程不会退出，因此可以一直对过期的session回收；</li>
</ul>
</li>
<li>SessionRegenerateID(w http.ResponseWriter, r *http.Request) (session Store)<ul>
<li>根据保存在请求头中的FileSessionStore，重新生成一个session；</li>
<li>调用manager.sessionID()，生成一个新的sessionID，sid；</li>
<li>这里跟SessionStart()有点类似，不过这里会先从请求头中获取名称为manager.config.CookieName的cookie，赋值为cookie，若cookie.Value == “”，则调用manager.provider.SessionRead(sid)，构造相应的&amp;http.Cookie{}，以备放入请求（响应）头中；若cookie.Value不为空的话，那么说明oldsid=url.QueryUnescape(cookie.Value)就不为空，此时就会调用manager.provider.SessionRegenerate(oldsid, sid)；</li>
<li>接下来的步骤跟SessionStart()中一样，就不在重复了；最后返回session；</li>
</ul>
</li>
<li>GetActiveSession() int<ul>
<li>获取有效的session数量；</li>
<li>调用manager.provider.SessionAll()</li>
</ul>
</li>
<li>SetSecure(secure bool)<ul>
<li>这个方法就是设置https cookie；</li>
<li>manager.config.Secure = secure；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>这里就全部说完了，注意我们这里仅仅是以session_file.go为例，使得我们的内容更具体化，当然你也可以结合session_mem.go来理解，但是都不会脱离Store和Provider这两个接口的，只是具体实现的方式有所不同，定义的*Store和*Provider结构体不一样罢了。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Beego-Session&quot;&gt;&lt;a href=&quot;#Beego-Session&quot; class=&quot;headerlink&quot; title=&quot;Beego Session&quot;&gt;&lt;/a&gt;Beego Session&lt;/h3&gt;&lt;p&gt;我们知道，beego在跑起来之前，调用了&lt;strong&gt;initBeforeHTTPRun()&lt;/strong&gt;这个函数。beego定义了一个全局不可导出的变量&lt;strong&gt;hooks&lt;/strong&gt;，这是一个切片，每个元素的类型是func() error，那么前面那个函数就往&lt;strong&gt;hooks&lt;/strong&gt;切片中追加元素，追加完成之后，会遍历&lt;strong&gt;hooks&lt;/strong&gt;切片，由于切片每一个元素都是函数类型，因此可以直接调用，&lt;strong&gt;hooks&lt;/strong&gt;切片中有这些元素：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;func registerMime() error&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;func registerDefaultErrorHandler() error&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;func registerSession() error&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;func registerTemplate() error&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;func registerAdmin() error&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;func registerGzip() error&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Go,Beego" scheme="https://ofttryaj.github.io/tags/Go-Beego/"/>
    
  </entry>
  
  <entry>
    <title>beego启动流程-配置</title>
    <link href="https://ofttryaj.github.io/2016/12/21/beego%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E9%85%8D%E7%BD%AE/"/>
    <id>https://ofttryaj.github.io/2016/12/21/beego启动流程-配置/</id>
    <published>2016-12-21T07:40:16.000Z</published>
    <updated>2016-12-21T07:49:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在beego包下有一个config.go文件，这个文件定义了beego的配置相关的结构体，有以下一些结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// 这是主配置结构，包含字段和Listen，WebConfig，LogConfig一些结构</div><div class="line">type Config struct &#123;</div><div class="line">	...</div><div class="line">	Listen              Listen</div><div class="line">	WebConfig           WebConfig</div><div class="line">	Log                 LogConfig</div><div class="line">&#125;</div><div class="line">// 与http和https相关的配置</div><div class="line">type Listen struct &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line">// web相关的配置，包含一个SessionConfig结构</div><div class="line">type WebConfig struct &#123;</div><div class="line">	...</div><div class="line">	Session                SessionConfig</div><div class="line">&#125;</div><div class="line">// seesion相关的配置</div><div class="line">type SessionConfig struct &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line">// 日志相关的配置</div><div class="line">type LogConfig struct &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line">// 这个结构体用于解析配置文件，目前beego只用到了ini provider，等下可以从下面的变量知道这一点</div><div class="line">type beegoAppConfig struct &#123;</div><div class="line">	// 这个接口定义了一些方法集，这些方法用于从配置文件中获取和设置值</div><div class="line">	// 比如beego的config包下面实现了这个接口的有xml，yaml，ini，json等</div><div class="line">	innerConfig config.Configer</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来定义了4个可导出的全局变量和两个不可导出的全局变量，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var (</div><div class="line">	// 应用的主体配置，即我们用bee工具新建的或者手动创建的应用</div><div class="line">	BConfig *Config</div><div class="line">	// beegoAppConfig依赖innerConfig字段来从配置文件中获取和设置值，即实现了config.Conffiger接口的对象</div><div class="line">	// 从下面的newAppConfig()函数中可以了解到，innerConfig就是config.IniConfig&#123;&#125;的实例</div><div class="line">	// 具体如何实现，可以去了解config.IniConfig具体方法的实现</div><div class="line">	AppConfig *beegoAppConfig</div><div class="line">	// 应用的绝对路径</div><div class="line">	AppPath string</div><div class="line">	// session.Manager的实例</div><div class="line">	GlobalSessions *session.Manager</div><div class="line">	// 应用配置文件的路径</div><div class="line">	appConfigPath string</div><div class="line">	// 这个变量是没有办法从外部更改的，除非强行改这里的代码，默认是ini provider</div><div class="line">	appConfigProvider = &quot;ini&quot;</div><div class="line">)</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>以上的全局变量(除了GlobalSeesions没有进行赋值)都在该文件中的init函数进行了赋值：</p>
<blockquote>
<p><strong>我们把beego编译好的可执行文件，这个可执行文件就是编译我们新建的App所生成的，暂且称为服务器启动命令</strong></p>
</blockquote>
<ol>
<li>首先调用了newConfig函数，这个函数返回一个<em>Config对象，进行了beego框架默认的配置赋值，并赋值给 <strong>BConfig</strong> 变量，这里面的RecoverPanic和RecoverFunc两个字段，表明是否从panic中恢复以及指定了recover函数，func recoverPanic()，这个函数就beego默认的recover函数，即打印出堆栈信息。当然我们也可以自定义recover函数，<em>*BConfig</em></em> 是一个全局可导出的变量，因此可以通过在服务器启动之前动态赋值；</li>
<li><p>接下来，设置当前 <strong>AppPath</strong> ，和当前工作路径workPath，AppPath就是服务器启动命令所在的绝对路径，workPath就是运行服务器启动命令时所在的路径，即当前路径。接着会检测AppPath和workPath两个目录下是否存在app.conf配置文件，会优先从workPath中判断，若没有则继续判断AppPath是否存在，任何一个存在则把相应的文件路径赋值给 <strong>appConfigPath</strong> ，若都不存在app.conf文件，会为 <strong>AppConfig</strong> 赋值为 <strong>&amp;beegoAppConfig{innerConfig: config.NewFakeConfig()}</strong> ；</p>
<pre><code>针对AppPath和workPath举个例子来说明下，我的GOPATH是/Users/llrve/workspaces/go/wego，目录结构如下:
wego
  |- bin
  |- pkg
  |- src
      |- github.com 第三方包
      |- gopkg.in 第三方包
      |- wechat bee工具创建的App
               |- ... 不全部列举出来
               |- main.go 入口文件
               |- wechat 这个就是服务器启动命令
当在/Users/llrve/workspaces/go/wego目录，这样启动src/wechat/wechat,
这时候AppPath是/Users/llrve/workspaces/go/wego/src/wechat，workPath则是/Users/llrve/workspaces/go/wego，
当在/Users/llrve/workspaces/go/wego/src/wechat目录下，
这样启动./wechat，AppPath和workPath都是/Users/llrve/workspaces/go/wego/src/wechat

因此AppPath跟服务器启动命令的位置有关
</code></pre></li>
<li><p>若存在则会去解析这个配置文件，调用当前文件中的parseConfig()函数，这个函数执行流程如下：</p>
<ul>
<li>调用当前文件中的newAppConfig函数即newAppConfig(appConfigProvider, appConfigPath)，注意这两个参数，appConfigProvider是前面定义的全局变量，其值为”ini”，appConfigPath使我们经过判断获取的app.conf文件的路径，这个函数返回一个&amp;beegoAppConfig{ac}，若没有错误，则赋值给 <strong>AppConfig</strong>，到这里，上面列举的所有全局变量均已赋值；<ul>
<li>我们来看下beego框架中config包下的ini.go文件中，有一个init函数，这个函数只有一行代码，就是调用当前包的一个函数Register(“ini”, &amp;IniConfig{});这个函数签名func Register(name string, adapter Config)，就是把&amp;IniConfig赋值给config包下的不可导出adapters map[string]Config中，即adapters[“ini”] = &amp;IniConfig{}，显然IniConfig实现了Config接口；</li>
<li>上面说了如何注册配置解析，接下来我们来看看newAppConfig()函数，首先调用config.NewConfig(“init”, AppPath/app.conf)，这个函数其实就是从config包的adapters变量中获取一个adapter，即adapters[“ini”]，上面我们看到beego如何注册一个IniConfig adapter，这里就能理解了，接着就调用了IniConfig.Parse(appConfPath)，这个方法返回值(Configer，error)，我们知道IniConfig.Parse方法返回的是config.IniConfigContainer，这个结构体也实现了config.Configer接口，因此把它赋值给beegoAppConfig.innerConfig也就合理了；</li>
</ul>
</li>
<li>接下来调用当前文件中的assignConfig函数，assignConfig(ac config.Configer)，AppConfig的类型是beegoAppConfig，而beegoAppConfig实现了config.Configer接口，assignConfig函数做了以下两类操作：<ul>
<li>读取app.conf配置文件的配置项，追加或覆盖到配置相应的字段中；<ul>
<li>若配置了环境变量os.Getenv(“BEEGO_RUNMODE”)，优先使用而这个，否则获取appConfigPath文件中配置的RunMode，若配置了的话，就覆盖BConfig.RunMode字段；之后会对几个字段进行特别的处理，因为这些字段的类型有点复杂，所以单独处理，BConfig.WebConfig.StaticDir，BConfig.WebConfig.StaticExtensionsToGzip，BConfig.Log.Outputs，即读取app.conf配置文件的配置内容，覆盖或追加到相应的字段中；</li>
<li>剩下的就是调用assignSingleConfig函数，对BConfig，BConfig.Listen，BConfig.WebConfig，BConfig.Log，BConfig.WebConfig.Session类型为bool，string，int，int64的字段替换为app.conf配置文件中相应的配置内容；</li>
</ul>
</li>
<li>设置日志操作；</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>这样beego配置相关的都完成了，包括一些全局变量的赋值操作，配置的初始化以及将应用的配置信息覆盖或追加到相应的字段中，接下来就可以读取配置信息，进行相关的操作了。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在beego包下有一个config.go文件，这个文件定义了beego的配置相关的结构体，有以下一些结构体：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// 这是主配置结构，包含字段和Listen，WebConfig，LogConfig一些结构&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;type Config struct &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	Listen              Listen&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	WebConfig           WebConfig&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	Log                 LogConfig&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 与http和https相关的配置&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;type Listen struct &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// web相关的配置，包含一个SessionConfig结构&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;type WebConfig struct &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	Session                SessionConfig&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// seesion相关的配置&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;type SessionConfig struct &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 日志相关的配置&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;type LogConfig struct &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 这个结构体用于解析配置文件，目前beego只用到了ini provider，等下可以从下面的变量知道这一点&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;type beegoAppConfig struct &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	// 这个接口定义了一些方法集，这些方法用于从配置文件中获取和设置值&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	// 比如beego的config包下面实现了这个接口的有xml，yaml，ini，json等&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	innerConfig config.Configer&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来定义了4个可导出的全局变量和两个不可导出的全局变量，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var (&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	// 应用的主体配置，即我们用bee工具新建的或者手动创建的应用&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	BConfig *Config&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	// beegoAppConfig依赖innerConfig字段来从配置文件中获取和设置值，即实现了config.Conffiger接口的对象&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	// 从下面的newAppConfig()函数中可以了解到，innerConfig就是config.IniConfig&amp;#123;&amp;#125;的实例&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	// 具体如何实现，可以去了解config.IniConfig具体方法的实现&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	AppConfig *beegoAppConfig&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	// 应用的绝对路径&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	AppPath string&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	// session.Manager的实例&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	GlobalSessions *session.Manager&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	// 应用配置文件的路径&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	appConfigPath string&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	// 这个变量是没有办法从外部更改的，除非强行改这里的代码，默认是ini provider&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	appConfigProvider = &amp;quot;ini&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="go,beego" scheme="https://ofttryaj.github.io/tags/go-beego/"/>
    
  </entry>
  
</feed>
